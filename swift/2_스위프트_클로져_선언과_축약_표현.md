# Swift Functional Programming



### ìŠ¤ìœ„í”„íŠ¸ì— ì´ëŸ°ê²Œ ìžˆì—ˆë‹¤ë‹ˆ

Swift ë¬¸ì„œì˜ closureì„ ì½ì–´ë³´ë‹¤ê°€ í´ë¡œì €ì˜ ë‹¤ì–‘í•œ í™œìš© ë°©ë²•ë“¤ì„ ë°œê²¬í–ˆë‹¤. ðŸ˜³

#### anonymous function syntax (ìž„ì˜í•¨ìˆ˜ ìž‘ì„± ì‹ í…ìŠ¤)

```swift
/*
 * { (parameters) -> return type in
 *   statements
 * }
 */
```

```swift
var reversedNames = names.sorted(by: 
 { 
   (s1: String, s2: String) -> Bool in
    return s1 > s2
 }
)

```

#### inferring type from context (ì»¨í…ìŠ¤íŠ¸ë¡œë¶€í„° íƒ€ìž…ì¶”ë¡ í•˜ê¸°)

sorting closureì´ ë©”ì†Œë“œì˜ ì „ë‹¬ì¸ìžë¡œ ë“¤ì–´ê°€ê¸° ë•Œë¬¸ì— í•´ë‹¹ í´ë¡œì €ì˜ ë§¤ê°œë³€ìˆ˜ì™€ ë¦¬í„´ê°’ì— ëŒ€í•œ ì¶”ë¡ ì´ ì´ë¤„ì§ˆ ìˆ˜ ìžˆë‹¤. sorted ë©”ì†Œë“œê°€ string arrayë¡œë¶€í„° ì‹¤í–‰ë˜ê¸° ë–„ë¬¸ì— (string, string) -> Bool ì´ë¼ëŠ” íƒ€ìž…ì„ ê°€ì§„ë‹¤ëŠ” ì ì„ ì•Œ ìˆ˜ ìžˆë‹¤. ê·¸ë ‡ê¸° ë•Œë¬¸ì— í•´ë‹¹ ë¶€ë¶„ì„ êµ³ì´ ì ì§€ ì•Šê³ ë„ ìž„ì˜í•¨ìˆ˜ë¥¼ ìž‘ì„±í•  ìˆ˜ ìžˆë‹¤.

```swift
var reversedNames = names.sorted(by: { s1, s2  in return s1 > s2 } )
```

#### implicit returns from single-expression closures (ë‹¨ì¼ í‘œí˜„ í´ë¡œì €ì—ì„œì˜ ì•”ì‹œì  ë°˜í™˜)

í´ë¡œì €ì˜ ë³¸ë¬¸ì´ ë‹¨ì¼ í‘œí˜„ì¼ ê²½ìš°ì—ëŠ” return í‚¤ì›Œë“œë¥¼ ìƒëžµí•  ìˆ˜ ìžˆë‹¤. 

```swift
var reversedNames = names.sorted(by: { s1, s2 in s1 > s2 } )
```

#### shorthand argument names (ì „ë‹¬ì¸ìžëª…ì˜ ì¶•ì•½)

ìŠ¤ìœ„í”„íŠ¸ì—ì„œëŠ” ì „ë‹¬ì¸ìž ì´ë¦„ ëŒ€ì‹  ì‚¬ìš©í•  ìˆ˜ ìžˆëŠ” ì¶•ì•½ëœ ë²„ì „ì˜ ì „ë‹¬ì¸ìž ì´ë¦„ë“¤ì„ ì œê³µí•œë‹¤. \$0, \$1, $2 ...ëŠ” í´ë¡œì €ì˜ ì „ë‹¬ì¸ìžë“¤ ìˆœì„œëŒ€ë¡œ ì°¸ì¡°í•œë‹¤.

ì¶•ì•½ëœ ì „ë‹¬ì¸ìžëª…ì„ ì‚¬ìš©í•˜ë©´, í´ë¡œì €ì˜ ì „ë‹¬ì¸ìžë“¤ì„ ìƒëžµí•´ë„ ë˜ê³  ì¶”ê°€ì ìœ¼ë¡œ in í‚¤ì›Œë“œë„ ìƒëžµí•  ìˆ˜ ìžˆê²Œëœë‹¤.

```swift
var reversedNames = name.sored(by: { $0 > $1 } )
```

#### operator methods (ì—°ì‚°ìž ë©”ì†Œë“œ)

ìœ„ë³´ë‹¤ ë” ì§§ì€ ì½”ë“œë¡œ êµ¬í˜„ì´ ê°€ëŠ¥í•œ ë°©ë²•ì´ ìžˆë‹¤. ë°”ë¡œ ì—°ì‚°ìž ë©”ì†Œë“œë¥¼ ì‚¬ìš©í•˜ëŠ” ë°©ë²•ì´ë‹¤. ë¬¸ìžì—´ íƒ€ìž…ì—ëŠ” > ì—°ì‚°ìžê°€ (String, String) ì „ë‹¬ì¸ìžë¥¼ ë°›ê³  Bool ì„ ë°˜í™˜í•˜ëŠ” ë©”ì†Œë“œë¡œ êµ¬í˜„ì´ ë˜ì–´ìžˆë‹¤. ê·¸ë ‡ê¸° ë–„ë¬¸ì— í´ë¡œì € ëŒ€ì‹ ì— > ì—°ì‚°ìžë§Œ ë„£ì–´ì„œë„ ìœ„ì™€ ê°™ì´ ë™ìž‘í•˜ëŠ” ì½”ë“œë¥¼ ìž‘ì„±í•  ìˆ˜ ìžˆë‹¤. ðŸ˜± ì©ë‹¤

```swift
var reversedNames = name.sorted(by: > )
```

#### trailing closure (ë’¤ë”°ë¼ì˜¤ëŠ” í´ë¡œì ¸)

í´ë¡œì €ë¥¼ ì „ë‹¬ì¸ìžë¡œ ë°›ëŠ” í•¨ìˆ˜ê°€ ìžˆë‹¤. í•´ë‹¹ í•¨ìˆ˜ë¥¼ ì‹¤í–‰í•  ë•Œ ë§¤ê°œë³€ìˆ˜ë¡œ í´ë¡œì €ë¥¼ ë„£ì–´ì£¼ëŠ” ë°©ë²• ì™¸ì—ë„, í•¨ìˆ˜ì˜ () ê´„í˜¸ ë’¤ì— í´ë¡œì €ë¥¼ ëª…ì‹œí•´ì¤˜ë„ ë™ì¼í•˜ê²Œ ìž‘ë™í•œë‹¤.

```swift
var reversedNames = name.sorted() { $0 > $1 }
```

ë§Œì•½ í•´ë‹¹ í•¨ìˆ˜ëŠ” í´ë¡œì € ì „ë‹¬ì¸ìž 1ê°œë§Œ ë°›ê³ , trailing closureë¡œ ìž‘ì„±í–ˆì„ ê²½ìš°ì—ëŠ” ê´„í˜¸ () ë¥¼ ìƒëžµí•´ë„ ëœë‹¤.

```swift
var reversedNames = name.sorted { $0 > $1 }
```

#### escaping closures (ë‹¬ì•„ë‚˜ëŠ” í´ë¡œì ¸)

í´ë¡œì €ê°€ í•¨ìˆ˜ì— ì¸ìžë¡œ ë“¤ì–´ê°€ê³ , í•´ë‹¹ í•¨ìˆ˜ê°€ ì¢…ë£Œëœ ì´í›„ì— í´ë¡œì €ê°€ ì‹¤í–‰ë˜ëŠ” í˜„ìƒì„ í´ë¡œì €ê°€ ë‹¬ì•„ë‚¬ë‹¤ê³  í‘œí˜„í•œë‹¤. 

```swift
var completionHandlers = [() -> Void]() // ()->Void íƒ€ìž…ì„ ê°€ì§€ëŠ” ë°°ì—´ì„ ìƒì„±
func someFunctionsWithEscapingClosure(completionHandler: @escaping () -> Void) {
  completionHandlers.append(completionHandler)
}
```

#### ìž„ì˜í•¨ìˆ˜ ì¦‰ì‹œì‹¤í–‰

```swift
func fizzbuzzDeclarative() {
    let fizz: (Int) -> String = { index in index % 3 == 0 ? "fizz" : ""}
    let buzz: (Int) -> String = { index in index % 5 == 0 ? "buzz" : ""}
    let fizzbuzz: (Int) -> String = { index in
        // fizz(index) + buzz(index)ë¥¼ ì¸ìžë¡œ ë„£ì–´ í•´ë‹¹ ìž„ì˜í•¨ìˆ˜ë¥¼ ì¦‰ì‹œ ì‹¤í–‰.
        {  result in // type infer (íƒ€ìž…ì¶”ë¡ ) ìœ¼ë¡œ íƒ€ìž… ëª…ì‹œ ìƒëžµ
            result.isEmpty ? "\(index)" : result // return ìƒëžµ
        }(fizz(index) + buzz(index))
    }
    let output: (String) -> () = { print($0) }
    
    (1...100).map(fizzbuzz).forEach(output)
}
```
